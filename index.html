<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Deluxe</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Modern color palette */
            --yellow-color: #FFD93D;
            --green-color: #4CAF50;
            --red-color: #FF6B6B;
            --blue-color: #4A90E2;
            
            --yellow-piece: #FFE169;
            --green-piece: #6BCB77;
            --red-piece: #FF8787;
            --blue-piece: #62A6E5;

            --neutral-bg: #F5F5F5;
            --board-bg: #ffffff;
            --border-color: rgba(0, 0, 0, 0.05);
            --text-color: #2C3E50;
            --text-light: #5D7285;
            --cell-size: 35px;
            --piece-size-factor: 0.8;
            --base-font: 'Poppins', sans-serif;
            --path-bg: rgba(0, 0, 0, 0.1);
            --path-border: rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: var(--base-font);
            background-color: var(--neutral-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            color: var(--text-color);
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .game-title {
            font-size: 2.5em;
            font-weight: 700;
            color: var(--text-color);
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            width: 100%;
        }

        .game-area {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            background-color: var(--board-bg);
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            padding: 35px;
            gap: 30px;
            max-width: 95vw;
            margin: 0 auto;
        }

        .board-container {
            flex-shrink: 0;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 25px;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 20px;
            min-width: 220px;
            align-items: center;
        }

        #ludo-board {
            display: grid;
            grid-template-columns: repeat(15, var(--cell-size));
            grid-template-rows: repeat(15, var(--cell-size));
            position: relative;
            margin-bottom: 35px;
            border-radius: 20px;
            overflow: hidden;
            background: var(--board-bg);
            box-shadow: 0 0 40px rgba(0,0,0,0.05);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: none;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--cell-size) * 0.45);
            position: relative;
            background-color: var(--board-bg);
            transition: background-color 0.3s ease;
        }

        /* Update path styling to be more visible */
        .cell[data-r="6"][data-c="1"],
        .cell[data-r="6"][data-c="2"],
        .cell[data-r="6"][data-c="3"],
        .cell[data-r="6"][data-c="4"],
        .cell[data-r="6"][data-c="5"],
        .cell[data-r="5"][data-c="6"],
        .cell[data-r="4"][data-c="6"],
        .cell[data-r="3"][data-c="6"],
        .cell[data-r="2"][data-c="6"],
        .cell[data-r="1"][data-c="6"],
        .cell[data-r="0"][data-c="6"],
        .cell[data-r="0"][data-c="7"],
        .cell[data-r="0"][data-c="8"],
        .cell[data-r="1"][data-c="8"],
        .cell[data-r="2"][data-c="8"],
        .cell[data-r="3"][data-c="8"],
        .cell[data-r="4"][data-c="8"],
        .cell[data-r="5"][data-c="8"],
        .cell[data-r="6"][data-c="9"],
        .cell[data-r="6"][data-c="10"],
        .cell[data-r="6"][data-c="11"],
        .cell[data-r="6"][data-c="12"],
        .cell[data-r="6"][data-c="13"],
        .cell[data-r="6"][data-c="14"],
        .cell[data-r="7"][data-c="14"],
        .cell[data-r="8"][data-c="14"],
        .cell[data-r="8"][data-c="13"],
        .cell[data-r="8"][data-c="12"],
        .cell[data-r="8"][data-c="11"],
        .cell[data-r="8"][data-c="10"],
        .cell[data-r="8"][data-c="9"],
        .cell[data-r="9"][data-c="8"],
        .cell[data-r="10"][data-c="8"],
        .cell[data-r="11"][data-c="8"],
        .cell[data-r="12"][data-c="8"],
        .cell[data-r="13"][data-c="8"],
        .cell[data-r="14"][data-c="8"],
        .cell[data-r="14"][data-c="7"],
        .cell[data-r="14"][data-c="6"],
        .cell[data-r="13"][data-c="6"],
        .cell[data-r="12"][data-c="6"],
        .cell[data-r="11"][data-c="6"],
        .cell[data-r="10"][data-c="6"],
        .cell[data-r="9"][data-c="6"],
        .cell[data-r="8"][data-c="5"],
        .cell[data-r="8"][data-c="4"],
        .cell[data-r="8"][data-c="3"],
        .cell[data-r="8"][data-c="2"],
        .cell[data-r="8"][data-c="1"],
        .cell[data-r="8"][data-c="0"],
        .cell[data-r="7"][data-c="0"],
        .cell[data-r="6"][data-c="0"] {
            background-color: var(--path-bg);
            border: 1.5px solid var(--path-border);
            border-radius: 4px;
            margin: 1px;
            width: calc(var(--cell-size) - 2px);
            height: calc(var(--cell-size) - 2px);
        }

        /* Safe cell styling - make it more visible */
        .safe-cell-marker {
            color: rgba(0, 0, 0, 0.4);
            font-size: calc(var(--cell-size) * 0.8);
            position: absolute;
        }

        /* Home paths with increased visibility */
        .home-path-yellow { 
            background: linear-gradient(135deg, var(--yellow-color) 0%, #FFB300 100%);
            opacity: 0.25;
            border: 1.5px solid rgba(255, 179, 0, 0.3);
            border-radius: 4px;
            margin: 1px;
            width: calc(var(--cell-size) - 2px);
            height: calc(var(--cell-size) - 2px);
        }

        .home-path-green { 
            background: linear-gradient(135deg, var(--green-color) 0%, #388E3C 100%);
            opacity: 0.25;
            border: 1.5px solid rgba(56, 142, 60, 0.3);
            border-radius: 4px;
            margin: 1px;
            width: calc(var(--cell-size) - 2px);
            height: calc(var(--cell-size) - 2px);
        }

        .home-path-red { 
            background: linear-gradient(135deg, var(--red-color) 0%, #E53935 100%);
            opacity: 0.25;
            border: 1.5px solid rgba(229, 57, 53, 0.3);
            border-radius: 4px;
            margin: 1px;
            width: calc(var(--cell-size) - 2px);
            height: calc(var(--cell-size) - 2px);
        }

        .home-path-blue { 
            background: linear-gradient(135deg, var(--blue-color) 0%, #1976D2 100%);
            opacity: 0.25;
            border: 1.5px solid rgba(25, 118, 210, 0.3);
            border-radius: 4px;
            margin: 1px;
            width: calc(var(--cell-size) - 2px);
            height: calc(var(--cell-size) - 2px);
        }

        .yard {
            position: absolute;
            width: calc(var(--cell-size) * 6);
            height: calc(var(--cell-size) * 6);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: calc(var(--cell-size) * 0.4);
            padding: calc(var(--cell-size) * 0.8);
            box-sizing: border-box;
            align-items: center;
            justify-items: center;
            border-radius: 15px;
        }

        .yellow-yard { 
            background: linear-gradient(135deg, var(--yellow-color) 0%, #FFB300 100%);
            top: 0; 
            left: 0; 
        }
        .green-yard { 
            background: linear-gradient(135deg, var(--green-color) 0%, #388E3C 100%);
            top: 0; 
            left: calc(var(--cell-size) * 9); 
        }
        .red-yard { 
            background: linear-gradient(135deg, var(--red-color) 0%, #E53935 100%);
            top: calc(var(--cell-size) * 9); 
            left: calc(var(--cell-size) * 9); 
        }
        .blue-yard { 
            background: linear-gradient(135deg, var(--blue-color) 0%, #1976D2 100%);
            top: calc(var(--cell-size) * 9); 
            left: 0; 
        }

        .piece-home-spot {
            width: calc(var(--cell-size) * 1.8);
            height: calc(var(--cell-size) * 1.8);
            background-color: rgba(255,255,255,0.2);
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Center styling for home triangles */
        .cell[data-r="7"][data-c="7"] {
            background: conic-gradient(
                from 0deg,
                rgba(255, 211, 61, 0.2) 0deg 90deg,
                rgba(76, 175, 80, 0.2) 90deg 180deg,
                rgba(255, 107, 107, 0.2) 180deg 270deg,
                rgba(74, 144, 226, 0.2) 270deg 360deg
            );
            border-radius: 3px;
        }

        .piece {
            width: calc(var(--cell-size) * var(--piece-size-factor));
            height: calc(var(--cell-size) * var(--piece-size-factor));
            border-radius: 50%;
            position: absolute;
            border: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            font-size: calc(var(--cell-size) * 0.38);
            color: rgba(255,255,255,0.9);
        }
        .piece.yellow { 
            background: linear-gradient(135deg, var(--yellow-piece) 0%, #FFB300 100%);
        }
        .piece.green { 
            background: linear-gradient(135deg, var(--green-piece) 0%, #388E3C 100%);
        }
        .piece.red { 
            background: linear-gradient(135deg, var(--red-piece) 0%, #E53935 100%);
        }
        .piece.blue { 
            background: linear-gradient(135deg, var(--blue-piece) 0%, #1976D2 100%);
        }

        .piece.movable {
            transform: scale(1.15);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            animation: pulse-movable 1.2s infinite alternate;
        }

        @keyframes pulse-movable {
            to {
                transform: scale(1.25);
                box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            }
        }

        .player-status-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        .player-score {
            padding: 12px 20px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            opacity: 0.8;
            width: 100%;
            text-align: center;
        }
        .player-score.active {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
            opacity: 1;
        }
        .player-score.yellow { background-color: var(--yellow-color); color: #333;}
        .player-score.green { background-color: var(--green-color); color: white;}
        .player-score.red { background-color: var(--red-color); color: white;}
        .player-score.blue { background-color: var(--blue-color); color: white;}

        #current-player-display {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-light);
        }

        #dice-display {
            font-size: calc(var(--cell-size) * 2);
            width: calc(var(--cell-size) * 2.5);
            height: calc(var(--cell-size) * 2.5);
            margin: 15px auto;
            background: var(--board-bg);
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #dice-display:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }

        #roll-dice-btn {
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(74, 144, 226, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            width: auto;
            margin: 0 auto;
            display: block;
            min-width: 140px;
        }

        #roll-dice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(74, 144, 226, 0.3);
            background: linear-gradient(135deg, #357ABD 0%, #2868A9 100%);
        }

        #roll-dice-btn:disabled {
            background: linear-gradient(135deg, #CBD5E0 0%, #A0AEC0 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #message-area {
            margin-top: 15px;
            min-height: 2em;
            font-weight: 500;
            font-size: 0.95em;
            color: var(--text-color);
            text-align: center;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0,0,0,0.02);
            max-width: 200px;
        }
        
        .new-game-btn {
            margin-top: 20px;
            padding: 14px 30px;
            font-size: 1.1em;
            font-weight: 600;
            background: linear-gradient(135deg, var(--green-color) 0%, #3d8b40 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 12px rgba(76, 175, 80, 0.3);
        }
        .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(76, 175, 80, 0.4);
            background: linear-gradient(135deg, #3d8b40 0%, #2d682f 100%);
        }

        /* Media query for smaller screens */
        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
                align-items: center;
                padding: 20px;
            }

            .controls-container {
                width: 100%;
                max-width: 400px;
            }

            :root {
                --cell-size: 30px;
            }
        }

    </style>
</head>
<body>
    <div class="game-title">Ludo Deluxe</div>
    <div class="game-area">
        <div class="board-container">
            <div id="ludo-board">
                <!-- Cells and Yards are generated by JS or can be pre-defined -->
                <div class="yard yellow-yard">
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                </div>
                <div class="yard green-yard">
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                </div>
                 <div class="yard red-yard">
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                </div>
                <div class="yard blue-yard">
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                    <div class="piece-home-spot"></div> <div class="piece-home-spot"></div>
                </div>
            </div>
        </div>
        <div class="controls-container">
            <div class="player-status-area">
                <div class="player-score yellow" id="player-yellow-score">Y: 0/4</div>
                <div class="player-score green" id="player-green-score">G: 0/4</div>
                <div class="player-score red" id="player-red-score">R: 0/4</div>
                <div class="player-score blue" id="player-blue-score">B: 0/4</div>
            </div>

            <div class="controls-area">
                <div id="current-player-display">Current Player: Yellow</div>
                <div id="dice-display" title="Click to roll dice">🎲</div>
                <button id="roll-dice-btn">Roll Dice</button>
                <div id="message-area">Roll a 6 to start!</div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const COLORS = ['yellow', 'green', 'red', 'blue'];
        const PIECES_PER_PLAYER = 4;
        const BOARD_SIZE = 15; 

        const MAIN_PATH = [
            {r:6, c:1}, {r:6, c:2}, {r:6, c:3}, {r:6, c:4}, {r:6, c:5}, 
            {r:5, c:6}, {r:4, c:6}, {r:3, c:6}, {r:2, c:6}, {r:1, c:6}, 
            {r:0, c:6}, {r:0, c:7}, {r:0, c:8}, 
            {r:1, c:8}, {r:2, c:8}, {r:3, c:8}, {r:4, c:8}, {r:5, c:8}, 
            {r:6, c:9}, {r:6, c:10}, {r:6, c:11}, {r:6, c:12}, {r:6, c:13},
            {r:6, c:14}, {r:7, c:14}, {r:8, c:14}, 
            {r:8, c:13}, {r:8, c:12}, {r:8, c:11}, {r:8, c:10}, {r:8, c:9}, 
            {r:9, c:8}, {r:10, c:8}, {r:11, c:8}, {r:12, c:8}, {r:13, c:8}, 
            {r:14, c:8}, {r:14, c:7}, {r:14, c:6},
            {r:13, c:6}, {r:12, c:6}, {r:11, c:6}, {r:10, c:6}, {r:9, c:6},  
            {r:8, c:5}, {r:8, c:4}, {r:8, c:3}, {r:8, c:2}, {r:8, c:1},   
            {r:8, c:0}, {r:7, c:0}, {r:6, c:0}  
        ];

        const PATH_START_OFFSET = { yellow: 0, green: 13, red: 26, blue: 39 };

        const SAFE_CELL_INDICES = [
            PATH_START_OFFSET.yellow, MAIN_PATH.findIndex(p => p.r===0 && p.c===6), 
            PATH_START_OFFSET.green,  MAIN_PATH.findIndex(p => p.r===6 && p.c===14),
            PATH_START_OFFSET.red,    MAIN_PATH.findIndex(p => p.r===14 && p.c===8),
            PATH_START_OFFSET.blue,   MAIN_PATH.findIndex(p => p.r===8 && p.c===0)  
        ].filter((value, index, self) => self.indexOf(value) === index); 

        const HOME_COLUMNS = {
            yellow: [{r:7,c:1}, {r:7,c:2}, {r:7,c:3}, {r:7,c:4}, {r:7,c:5}, {r:7,c:6}],
            green:  [{r:1,c:7}, {r:2,c:7}, {r:3,c:7}, {r:4,c:7}, {r:5,c:7}, {r:6,c:7}],
            red:    [{r:7,c:13}, {r:7,c:12}, {r:7,c:11}, {r:7,c:10}, {r:7,c:9}, {r:7,c:8}],
            blue:   [{r:13,c:7}, {r:12,c:7}, {r:11,c:7}, {r:10,c:7}, {r:9,c:7}, {r:8,c:7}]
        };

        const HOME_ENTRY_POINTS_MAIN_PATH_INDEX = {
            yellow: MAIN_PATH.findIndex(p => p.r===6 && p.c===0), 
            green:  MAIN_PATH.findIndex(p => p.r===0 && p.c===8), 
            red:    MAIN_PATH.findIndex(p => p.r===8 && p.c===14),
            blue:   MAIN_PATH.findIndex(p => p.r===14 && p.c===6) 
        };

        const DICE_UNICODE = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];

        // --- GAME LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('ludo-board');
            const diceDisplayElement = document.getElementById('dice-display');
            const rollDiceBtn = document.getElementById('roll-dice-btn');
            const currentPlayerDisplay = document.getElementById('current-player-display');
            const messageArea = document.getElementById('message-area');

            let players = [];
            let pieces = [];
            let currentPlayerIndex = 0;
            let diceValue = 0;
            let consecutiveSixes = 0;
            const CELL_SIZE_PX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));

            function initializeBoardCells() {
                boardElement.innerHTML = ''; // Clear previous cells if any (for re-init)
                // Re-add yards because innerHTML clears them
                ['yellow', 'green', 'red', 'blue'].forEach(color => {
                    const yard = document.createElement('div');
                    yard.className = `yard ${color}-yard`;
                    for(let i=0; i<4; i++) {
                        const spot = document.createElement('div');
                        spot.className = 'piece-home-spot';
                        yard.appendChild(spot);
                    }
                    boardElement.appendChild(yard);
                });

                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;

                        Object.keys(HOME_COLUMNS).forEach(color => {
                            HOME_COLUMNS[color].slice(0,5).forEach(hc => { 
                                if (hc.r === r && hc.c === c) {
                                    cell.classList.add(`home-path-${color}`);
                                }
                            });
                        });
                        const pathIdx = MAIN_PATH.findIndex(p => p.r === r && p.c === c);
                        if (pathIdx !== -1 && SAFE_CELL_INDICES.includes(pathIdx)) {
                            cell.innerHTML = '<span class="safe-cell-marker">★</span>';
                        }
                        if (r===7 && c===7) { /* Already styled by :root CSS */ }
                        boardElement.appendChild(cell);
                    }
                }
            }


            function initializeGame() {
                initializeBoardCells(); 
                players = []; // Reset players
                pieces = []; // Reset pieces

                // Clear any existing piece DOM elements from previous game
                document.querySelectorAll('.piece').forEach(p => p.remove());


                COLORS.forEach((color, playerIdx) => {
                    players.push({ id: playerIdx, color: color, piecesHome: 0 });
                    for (let i = 0; i < PIECES_PER_PLAYER; i++) {
                        const pieceId = `${color}-piece-${i}`;
                        pieces.push({
                            id: pieceId,
                            playerId: playerIdx,
                            color: color,
                            positionType: 'yard', 
                            pathPosition: -1,    
                            yardIndex: i,        
                            element: createPieceElement(pieceId, color, i + 1)
                        });
                    }
                });
                renderBoard();
                updatePlayerTurnDisplay();
                rollDiceBtn.disabled = false;
                messageArea.textContent = `${players[currentPlayerIndex].color.charAt(0).toUpperCase() + players[currentPlayerIndex].color.slice(1)}'s turn. Roll a 6 to start!`;
                 // Remove any "Play Again" button from previous game
                const oldNewGameBtn = document.querySelector('.new-game-btn');
                if (oldNewGameBtn) oldNewGameBtn.remove();
            }

            function createPieceElement(id, color, number) {
                const pieceEl = document.createElement('div');
                pieceEl.id = id;
                pieceEl.classList.add('piece', color);
                pieceEl.textContent = number; 
                pieceEl.addEventListener('click', () => handlePieceClick(id));
                boardElement.appendChild(pieceEl); 
                return pieceEl;
            }

            function renderBoard() {
                pieces.forEach(p => {
                    let top = 0, left = 0;
                    const pieceSize = CELL_SIZE_PX * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--piece-size-factor'));
                    const offsetToCenterPiece = (CELL_SIZE_PX - pieceSize) / 2;

                    if (p.positionType === 'yard') {
                        const yardDiv = document.querySelector(`.${p.color}-yard`);
                        const spots = yardDiv.getElementsByClassName('piece-home-spot');
                        if (spots[p.yardIndex]) {
                            const spotRect = spots[p.yardIndex].getBoundingClientRect();
                            const boardRect = boardElement.getBoundingClientRect();
                            top = spotRect.top - boardRect.top + (spotRect.height - pieceSize) / 2;
                            left = spotRect.left - boardRect.left + (spotRect.width - pieceSize) / 2;
                        }
                         p.element.style.zIndex = 1;
                    } else if (p.positionType === 'path') {
                        const cellCoords = MAIN_PATH[p.pathPosition];
                        top = cellCoords.r * CELL_SIZE_PX + offsetToCenterPiece;
                        left = cellCoords.c * CELL_SIZE_PX + offsetToCenterPiece;
                        p.element.style.zIndex = 5;
                    } else if (p.positionType === 'homecolumn') {
                        const cellCoords = HOME_COLUMNS[p.color][p.pathPosition];
                        top = cellCoords.r * CELL_SIZE_PX + offsetToCenterPiece;
                        left = cellCoords.c * CELL_SIZE_PX + offsetToCenterPiece;
                        p.element.style.zIndex = 5;
                    } else if (p.positionType === 'finished') {
                        const centerCellCoords = HOME_COLUMNS[p.color][HOME_COLUMNS[p.color].length -1]; 
                        top = centerCellCoords.r * CELL_SIZE_PX + offsetToCenterPiece + (Math.random()-0.5)*8 * (p.id.slice(-1)%2 == 0 ? 1 : -1) ; 
                        left = centerCellCoords.c * CELL_SIZE_PX + offsetToCenterPiece + (Math.random()-0.5)*8 * (p.id.slice(-1)%2 != 0 ? 1 : -1);
                        p.element.style.zIndex = 2; // Below active pieces but above yard
                    }
                    p.element.style.top = `${top}px`;
                    p.element.style.left = `${left}px`;
                    p.element.classList.remove('movable');
                });
                updatePlayerScores();
            }
            
            function updatePlayerScores() {
                players.forEach(player => {
                    const scoreEl = document.getElementById(`player-${player.color}-score`);
                    if (scoreEl) {
                        scoreEl.textContent = `${player.color.charAt(0).toUpperCase()}: ${player.piecesHome}/${PIECES_PER_PLAYER}`;
                    }
                });
            }

            function rollDice() {
                if (rollDiceBtn.disabled) return;

                diceValue = Math.floor(Math.random() * 6) + 1;
                
                // Dice roll animation
                diceDisplayElement.style.transition = 'transform 0.3s ease-out';
                diceDisplayElement.style.transform = `rotate(${Math.random() * 180 - 90}deg) scale(0.8)`;
                
                setTimeout(() => {
                    diceDisplayElement.textContent = DICE_UNICODE[diceValue - 1];
                    diceDisplayElement.style.transform = 'rotate(0deg) scale(1)';
                }, 150);


                messageArea.textContent = `${players[currentPlayerIndex].color.charAt(0).toUpperCase() + players[currentPlayerIndex].color.slice(1)} rolled a ${diceValue}.`;
                rollDiceBtn.disabled = true;

                if (diceValue === 6) {
                    consecutiveSixes++;
                    if (consecutiveSixes === 3) {
                        messageArea.textContent += " Rolled three 6s! Turn forfeited.";
                        setTimeout(nextTurn, 1500);
                        return;
                    }
                } else {
                    consecutiveSixes = 0;
                }

                const movablePieces = getMovablePiecesForCurrentPlayer(diceValue);

                if (movablePieces.length === 0) {
                    messageArea.textContent += " No possible moves.";
                    if (diceValue !== 6) {
                         setTimeout(nextTurn, 1500);
                    } else {
                         rollDiceBtn.disabled = false; 
                         messageArea.textContent += " Roll again!";
                    }
                } else if (movablePieces.length === 1 && !playerHasChoice(movablePieces, diceValue)) {
                    movePiece(movablePieces[0].id, diceValue);
                } else {
                    messageArea.textContent += " Click a piece to move.";
                    movablePieces.forEach(p => p.element.classList.add('movable'));
                }
            }
            
            function playerHasChoice(movablePieces, roll) {
                if (movablePieces.length > 1) return true;
                if (movablePieces.length === 1 && roll === 6) {
                    const piece = movablePieces[0];
                    if (piece.positionType === 'path' && pieces.some(p=>p.playerId === piece.playerId && p.positionType === 'yard')) {
                        return true;
                    }
                }
                return false;
            }

            function getMovablePiecesForCurrentPlayer(roll) {
                const currentPlayer = players[currentPlayerIndex];
                return pieces.filter(p => {
                    if (p.playerId !== currentPlayer.id || p.positionType === 'finished') return false;
                    if (p.positionType === 'yard') return roll === 6;
                    if (p.positionType === 'path') {
                        const homeEntryThreshold = HOME_ENTRY_POINTS_MAIN_PATH_INDEX[p.color];
                        let tempPos = p.pathPosition;
                        let stepsToEnterHomeCol = -1;
                        for (let i = 1; i <= roll; i++) {
                            if (tempPos === homeEntryThreshold) {
                                stepsToEnterHomeCol = roll - i;
                                break;
                            }
                            tempPos = (tempPos + 1) % MAIN_PATH.length;
                        }
                        if (stepsToEnterHomeCol !== -1) { 
                            return stepsToEnterHomeCol < HOME_COLUMNS[p.color].length;
                        }
                        return true; 
                    }
                    if (p.positionType === 'homecolumn') {
                        return p.pathPosition + roll < HOME_COLUMNS[p.color].length;
                    }
                    return false;
                });
            }

            function handlePieceClick(pieceId) {
                const piece = pieces.find(p => p.id === pieceId);
                if (!piece || !piece.element.classList.contains('movable')) return;
                pieces.forEach(p => p.element.classList.remove('movable'));
                movePiece(pieceId, diceValue);
            }

            function movePiece(pieceId, roll) {
                const piece = pieces.find(p => p.id === pieceId);
                const player = players[piece.playerId];
                let capturedOpponent = false;

                if (piece.positionType === 'yard' && roll === 6) {
                    piece.positionType = 'path';
                    piece.pathPosition = PATH_START_OFFSET[piece.color];
                    piece.yardIndex = -1;
                    // No message here, will be set after render
                } else if (piece.positionType === 'path') {
                    const homeEntryThreshold = HOME_ENTRY_POINTS_MAIN_PATH_INDEX[piece.color];
                    let currentGlobalPos = piece.pathPosition;
                    let stepsIntoHomeCol = -1;
                    let tempPos = currentGlobalPos;
                    for (let i = 1; i <= roll; i++) {
                        if (tempPos === homeEntryThreshold) {
                            stepsIntoHomeCol = roll - i;
                            break;
                        }
                        tempPos = (tempPos + 1) % MAIN_PATH.length;
                    }
                    if (stepsIntoHomeCol !== -1) { 
                        piece.positionType = 'homecolumn';
                        piece.pathPosition = stepsIntoHomeCol; 
                    } else { 
                        piece.pathPosition = (currentGlobalPos + roll) % MAIN_PATH.length;
                    }
                } else if (piece.positionType === 'homecolumn') {
                    piece.pathPosition += roll;
                }

                // Check for capture AFTER logical move, BEFORE render
                let message = `${player.color.charAt(0).toUpperCase() + player.color.slice(1)} moved.`;
                if (piece.positionType === 'yard' && roll === 6) message = `${player.color.charAt(0).toUpperCase() + player.color.slice(1)} moved a piece out!`;


                if (piece.positionType === 'path') {
                    const targetCellGlobalIndex = piece.pathPosition;
                    if (!SAFE_CELL_INDICES.includes(targetCellGlobalIndex)) {
                        pieces.forEach(otherPiece => {
                            if (otherPiece.id !== piece.id && // Don't capture self if multiple pieces on same spot (shouldn't happen with current logic)
                                otherPiece.playerId !== player.id &&
                                otherPiece.positionType === 'path' &&
                                otherPiece.pathPosition === targetCellGlobalIndex) {
                                otherPiece.positionType = 'yard';
                                const occupiedYardIndices = pieces.filter(p => p.playerId === otherPiece.playerId && p.positionType === 'yard').map(p => p.yardIndex);
                                for(let i=0; i<PIECES_PER_PLAYER; i++) {
                                    if(!occupiedYardIndices.includes(i)) {
                                        otherPiece.yardIndex = i;
                                        break;
                                    }
                                }
                                message = `${player.color.charAt(0).toUpperCase() + player.color.slice(1)} captured ${otherPiece.color}'s piece!`;
                                capturedOpponent = true;
                            }
                        });
                    }
                }

                if (piece.positionType === 'homecolumn' && piece.pathPosition === HOME_COLUMNS[piece.color].length - 1) {
                    piece.positionType = 'finished';
                    player.piecesHome++;
                    message = `${player.color.charAt(0).toUpperCase() + player.color.slice(1)} got a piece home!`;
                    if (player.piecesHome === PIECES_PER_PLAYER) {
                        renderBoard(); // Render before game over message
                        gameOver(player);
                        return;
                    }
                }
                
                messageArea.textContent = message; // Set message before render for context
                renderBoard(); // This call triggers the CSS animation due to top/left changes

                if (diceValue === 6 || capturedOpponent || piece.positionType === 'finished') {
                    rollDiceBtn.disabled = false;
                    messageArea.textContent += (diceValue === 6 ? " Roll again!" : (capturedOpponent || piece.positionType === 'finished' ? " Bonus turn!" : ""));
                } else {
                    setTimeout(nextTurn, 700); // Allow animation to mostly finish
                }
            }

            function nextTurn() {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                if (players.every(p => p.piecesHome === PIECES_PER_PLAYER)) return;
                while(players[currentPlayerIndex].piecesHome === PIECES_PER_PLAYER) {
                    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                }
                consecutiveSixes = 0;
                updatePlayerTurnDisplay();
                rollDiceBtn.disabled = false;
                diceValue = 0;
                messageArea.textContent = `${players[currentPlayerIndex].color.charAt(0).toUpperCase() + players[currentPlayerIndex].color.slice(1)}'s turn.`;
            }

            function updatePlayerTurnDisplay() {
                const player = players[currentPlayerIndex];
                currentPlayerDisplay.textContent = `Current Player: ${player.color.charAt(0).toUpperCase() + player.color.slice(1)}`;
                
                // Use actual color for player text
                const playerTrueColor = getComputedStyle(document.documentElement).getPropertyValue(`--${player.color}-color`).trim();
                currentPlayerDisplay.style.color = playerTrueColor || 'var(--text-light)';


                document.querySelectorAll('.player-score').forEach(el => el.classList.remove('active'));
                const activeScoreEl = document.getElementById(`player-${player.color}-score`);
                if (activeScoreEl) activeScoreEl.classList.add('active');
            }

            function gameOver(winner) {
                messageArea.textContent = `Game Over! ${winner.color.charAt(0).toUpperCase() + winner.color.slice(1)} wins!`;
                rollDiceBtn.disabled = true;
                const newGameBtn = document.createElement('button');
                newGameBtn.textContent = "Play Again?";
                newGameBtn.className = "new-game-btn"; // Added class for styling
                newGameBtn.onclick = () => initializeGame(); // Re-initialize instead of reload
                document.querySelector('.controls-area').appendChild(newGameBtn);
            }

            rollDiceBtn.addEventListener('click', rollDice);
            diceDisplayElement.addEventListener('click', rollDice);

            initializeGame();
        });
    </script>
</body>
</html>